<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>üï∂Ô∏è Tic Tac Vato ‚Äî Mini App</title>

  <!-- Farcaster Mini App / Frame metadata (no comments inside JSON) -->
  <meta name="fc:miniapp" content='{
    "version":"1",
    "imageUrl":"https://vato.sqmu.io/assets/og.jpg",
    "button":{
      "title":"Play Tic Tac Vato",
      "action":{
        "type":"launch_frame",
        "name":"Tic Tac Vato",
        "url":"https://vato.sqmu.io/index.html",
        "splashImageUrl":"https://vato.sqmu.io/assets/og.jpg",
        "splashBackgroundColor":"#FF6B00"
      }
    }
  }' />
  <meta name="fc:frame" content='{
    "version":"1",
    "imageUrl":"https://vato.sqmu.io/assets/og.jpg",
    "button":{
      "title":"Play Tic Tac Vato",
      "action":{
        "type":"launch_frame",
        "name":"Tic Tac Vato",
        "url":"https://vato.sqmu.io/index.html",
        "splashImageUrl":"https://vato.sqmu.io/assets/og.jpg",
        "splashBackgroundColor":"#FF6B00"
      }
    }
  }' />

  <style>
    body { font-family: 'Courier New', monospace; max-width: 420px; margin: 0 auto; padding: 20px; background: #121212; color: #f0f0f0; }
    h1 { color: #FF6B00; text-align: center; font-size: 2.2rem; margin: 6px 0 2px; text-shadow: 2px 2px 4px #000; }
    .subtitle { text-align: center; color: #aaa; margin-bottom: 18px; }
    #board { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin: 18px 0; background: #1E1E1E; padding: 10px; border-radius: 10px; box-shadow: 0 0 15px rgba(0,0,0,.5); }
    .cell { aspect-ratio: 1; background: #2A2A2A; border: 2px solid #FF6B00; display: flex; align-items: center; justify-content: center; font-size: 3rem; cursor: pointer; transition: all .2s; }
    .cell:hover { background: #333; transform: scale(1.04); }
    .cell.x { color: #4CAF50; } .cell.o { color: #F44336; }
    #status { font-weight: bold; margin: 12px 0; text-align: center; min-height: 40px; }
    .panel { background: #1E1E1E; padding: 10px; border-radius: 8px; margin: 10px 0; border-left: 4px solid #FF6B00; }
    .row { display: flex; gap: 10px; align-items: center; justify-content: space-between; }
    button { background: linear-gradient(135deg, #FF6B00 0%, #FF9500 100%); color: #fff; border: 0; padding: 12px 16px; border-radius: 8px; cursor: pointer; font-weight: 700; width: 100%; transition: transform .1s, box-shadow .1s; }
    button:hover { transform: translateY(-1px); box-shadow: 0 6px 16px rgba(255,107,0,.35); }
    button:disabled { background: #555; cursor: not-allowed; box-shadow: none; }
    #leaderboard ol { padding-left: 20px; margin: 8px 0 0; }
    small.mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; color: #bbb; }
  </style>
</head>
<body>
  <h1>TIC TAC VATO</h1>
  <div class="subtitle">Outwit the Code Cholo</div>

  <div class="panel" id="economy">
    <div class="row"><div>üè¶ Current Prize Pool</div><div><strong><span id="poolEth">‚Äî</span> ETH</strong></div></div>
    <div class="row"><div>üéü Entry Fee (1%)</div><div><strong><span id="feeEth">‚Äî</span> ETH</strong></div></div>
    <div class="row"><div>üìà Target</div><div><strong>0.100000 ETH</strong></div></div>
    <small class="mono">When the pool hits 0.1 ETH, top 3 spenders win 40%, 30% and 20%. The pool then resets to 0.001 ETH.</small>
  </div>

  <div class="row"><button id="connect">üîì Connect Wallet</button></div>
  <div class="row"><button id="play" disabled>üí∏ Pay & Play</button></div>

  <div id="board" style="display:none;">
    <div class="cell" data-index="0"></div>
    <div class="cell" data-index="1"></div>
    <div class="cell" data-index="2"></div>
    <div class="cell" data-index="3"></div>
    <div class="cell" data-index="4"></div>
    <div class="cell" data-index="5"></div>
    <div class="cell" data-index="6"></div>
    <div class="cell" data-index="7"></div>
    <div class="cell" data-index="8"></div>
  </div>

  <div id="status">Loading‚Ä¶</div>

  <div class="panel" id="leaderboard">
    <div class="row"><div>üèÜ Top Spenders</div></div>
    <ol id="lbList"><li>‚Äî</li><li>‚Äî</li><li>‚Äî</li></ol>
  </div>

  <script type="module">
    import { sdk } from 'https://esm.sh/@farcaster/miniapp-sdk';
    import {
      parseAbi, encodeFunctionData,
      createPublicClient, http
    } from 'https://esm.sh/viem@2.9.32';
    import { arbitrum } from 'https://esm.sh/viem/chains';

    (async () => {
      // Hide splash; ignore if not in host.
      try { await sdk.actions.ready(); } catch {}

      // Mini App provider (tx path)
      let provider;
      try { provider = await sdk.wallet.getEthereumProvider(); } catch {}

      const els = {
        poolEth: document.getElementById('poolEth'),
        feeEth:  document.getElementById('feeEth'),
        connect: document.getElementById('connect'),
        play:    document.getElementById('play'),
        status:  document.getElementById('status'),
        board:   document.getElementById('board'),
        lbList:  document.getElementById('lbList'),
      };

      const CONTRACT = '0xDB30fa8787C71Cf725E5b377130Df5fBEB3BbF5E'; // UUPS proxy
      const ABI = parseAbi([
        'function prizePool() view returns (uint256)',
        'function currentFee() view returns (uint256)',
        'function getLeaderboard() view returns (address[3], uint256[3])',
        'function play() payable'
      ]);

      // READS: use RPC only (provider blocks eth_call)
      const pub = createPublicClient({ chain: arbitrum, transport: http('https://arb1.arbitrum.io/rpc') });

      const ARBITRUM_HEX = '0xa4b1';
      const ETH = 10n ** 18n;
      const to6 = (wei) => {
        const w = BigInt(wei);
        const whole = w / ETH;
        const frac  = ((w % ETH) * 1_000_000n) / ETH;
        return `${whole}.${frac.toString().padStart(6, '0')}`;
      };

      async function readPrizePool() {
        return pub.readContract({ address: CONTRACT, abi: ABI, functionName: 'prizePool' });
      }
      async function readCurrentFee() {
        return pub.readContract({ address: CONTRACT, abi: ABI, functionName: 'currentFee' });
      }
      async function readLeaderboard() {
        const [addrs, amts] = await pub.readContract({ address: CONTRACT, abi: ABI, functionName: 'getLeaderboard' });
        return { addrs, amts };
      }

      async function refreshUI() {
        try {
          const [poolWei, feeWei, lb] = await Promise.all([readPrizePool(), readCurrentFee(), readLeaderboard()]);
          els.poolEth.textContent = to6(poolWei);
          els.feeEth.textContent  = to6(feeWei);
          const rows = [0,1,2].map(i => {
            const a = lb.addrs[i], v = BigInt(lb.amts[i] || 0);
            if (!a || a.toLowerCase() === '0x0000000000000000000000000000000000000000' || v === 0n) return null;
            return `<li>${a.slice(0,6)}‚Ä¶${a.slice(-4)} ‚Äî ${to6(v)} ETH</li>`;
          }).filter(Boolean);
          els.lbList.innerHTML = rows.length ? rows.join('') : '<li>‚Äî</li><li>‚Äî</li><li>‚Äî</li>';
          els.status.textContent = provider ? 'Tap Connect to play.' : 'Viewing only. Open in Farcaster app to play.';
        } catch (e) {
          console.error(e);
          els.status.textContent = 'Failed to read on-chain state.';
        }
      }

      await refreshUI();

      // ‚Äî‚Äî‚Äî Connect & ensure Arbitrum ‚Äî‚Äî‚Äî
      const needsHost = () => !provider || typeof provider.request !== 'function';
      async function ensureArbitrum() {
        const cid = await provider.request({ method: 'eth_chainId' });
        if (cid !== ARBITRUM_HEX) {
          await provider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: ARBITRUM_HEX }] });
        }
      }

      let player = '';
      els.connect.onclick = async () => {
        if (needsHost()) {
          els.status.textContent = 'Open in Farcaster app to connect wallet.';
          return;
        }
        try {
          await provider.request({ method: 'eth_requestAccounts' });
          const accounts = await provider.request({ method: 'eth_accounts' });
          player = accounts[0] || '';
          if (!player) return;
          await ensureArbitrum();
          els.connect.textContent = `‚úÖ ${player.slice(0,6)}‚Ä¶${player.slice(-4)}`;
          els.connect.style.background = '#4CAF50';
          els.play.disabled = false;
          els.status.textContent = 'Ready. Pay to play.';
          await refreshUI();
        } catch (e) {
          console.error(e);
          els.status.textContent = e?.message || 'Wallet connection failed.';
        }
      };

      // ‚Äî‚Äî‚Äî Game logic ‚Äî‚Äî‚Äî
      let board = ["","","","","","","","",""];
      let gameActive = false;
      const cells = [...document.querySelectorAll('.cell')];

      function checkEnd() {
        const W = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
        let win = null;
        for (const [a,b,c] of W) if (board[a] && board[a]===board[b] && board[a]===board[c]) { win = board[a]; break; }
        if (win || !board.includes("")) {
          gameActive = false;
          if (win === "X") els.status.innerHTML = "üéâ <strong>You won!</strong>";
          else if (win === "O") els.status.innerHTML = "üíÄ <strong>Vato smoked you!</strong> Pay to try again";
          else els.status.innerHTML = "ü§ù <strong>Draw</strong>";
          els.play.style.display = "block";
          return true;
        }
        return false;
      }
      function minimax(b, p) {
        const W = [[0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]];
        const opp = p === "X" ? "O" : "X";
        for (const [i, j, k] of W)
          if (b[i] && b[i] === b[j] && b[i] === b[k]) return { score: b[i] === "O" ? 10 : -10 };
        if (!b.includes("")) return { score: 0 };
        const moves = [];
        for (let idx = 0; idx < 9; idx++) if (b[idx] === "") {
          b[idx] = p;
          const result = minimax(b, opp);
          moves.push({ index: idx, score: result.score });
          b[idx] = "";
        }
        return (p === "O")
          ? moves.reduce((best, x) => x.score > best.score ? x : best, moves[0])
          : moves.reduce((best, x) => x.score < best.score ? x : best, moves[0]);
      }
      function vatoMove() {
        els.status.innerHTML = "ü§î <strong>Vato thinking‚Ä¶</strong>";
        setTimeout(()=>{
          const m = minimax([...board], "O");
          board[m.index]="O";
          const cell = document.querySelector(`.cell[data-index="${m.index}"]`);
          cell.textContent="O"; cell.classList.add('o');
          checkEnd();
        }, 600);
      }
      function resetBoard() {
        board = ["","","","","","","","",""];
        cells.forEach(c=>{ c.textContent=""; c.className="cell"; });
      }
      cells.forEach(c => c.addEventListener('click', e => {
        if (!gameActive) return;
        const i = +e.currentTarget.dataset.index;
        if (board[i] !== "") return;
        board[i] = "X";
        e.currentTarget.textContent = "X";
        e.currentTarget.classList.add('x');
        if (checkEnd()) return;
        vatoMove();
      }));

      // ‚Äî‚Äî‚Äî Pay & Play: estimate first, then send ‚Äî‚Äî‚Äî
      els.play.onclick = async () => {
        if (!provider || typeof provider.request !== 'function') {
          els.status.textContent = 'Open in Farcaster app to play.';
          return;
        }
        try {
          await ensureArbitrum();
          const [from] = await provider.request({ method: 'eth_accounts' }) || [];
          if (!from) throw new Error('No wallet account connected.');

          // Read fee from RPC (cheap & reliable)
          const feeWei = await readCurrentFee();
          els.status.innerHTML = `‚è≥ <strong>Preparing ${to6(feeWei)} ETH‚Ä¶</strong>`;

          const data = encodeFunctionData({ abi: ABI, functionName: 'play', args: [] });
          const tx = { from, to: CONTRACT, data, value: '0x' + BigInt(feeWei).toString(16) };

          // Pre-flight: estimate gas to catch ‚Äúinsufficient funds‚Äù up front
          try {
            await provider.request({ method: 'eth_estimateGas', params: [tx] });
          } catch (estErr) {
            const msg = (estErr?.message || '').toLowerCase();
            if (msg.includes('insufficient') || msg.includes('funds')) {
              els.status.innerHTML = `‚ùå <strong>Insufficient ETH for fee + gas.</strong><br><small class="mono">Tip: top up a bit more on Arbitrum (e.g., ~0.0002‚Äì0.0005 ETH) to cover L2 gas + L1 data fees.</small>`;
              return;
            }
            // If estimate fails for another reason, we still try sending so the wallet can explain.
          }

          els.status.innerHTML = `‚è≥ <strong>Paying ${to6(feeWei)} ETH‚Ä¶</strong>`;
          await provider.request({ method: 'eth_sendTransaction', params: [tx] });

          // Refresh reads after a moment
          setTimeout(refreshUI, 1500);

          resetBoard();
          gameActive = true;
          els.board.style.display = "grid";
          els.play.style.display = "none";
          els.status.innerHTML = "üî´ <strong>Your move</strong> (You're X)";
        } catch (err) {
          console.error(err);
          els.status.innerHTML = `‚ùå <strong>Error:</strong> ${err?.message || err}`;
        }
      };
    })();
  </script>
</body>
</html>
